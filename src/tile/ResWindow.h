/**
 *    Copyright (C) 2016-2022 Grok Image Compression Inc.
 *
 *    This source code is free software: you can redistribute it and/or  modify
 *    it under the terms of the GNU Affero General Public License, version 3,
 *    as published by the Free Software Foundation.
 *
 *    This source code is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Affero General Public License for more details.
 *
 *    You should have received a copy of the GNU Affero General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
#pragma once

#include "grk_includes.h"
#include <algorithm>

/*
 Various coordinate systems are used to describe regions in the tile component buffer.

 1) Canvas coordinates:  JPEG 2000 global image coordinates.

 2) Tile component coordinates: canvas coordinates with sub-sampling applied

*/

namespace grk
{

enum eBandOrientation
{
	BAND_ORIENT_LL,
	BAND_ORIENT_HL,
	BAND_ORIENT_LH,
	BAND_ORIENT_HH,
	BAND_NUM_ORIENTATIONS
};

template<typename T>
struct TileComponentWindow;

/**
 * ResWindow
 *
 * Manage all buffers for a single DWT resolution.
 * Note: padded elements may have zero padding, for example
 * in the case of whole tile inverse wavelet
 */
template<typename T>
struct ResWindow
{
	friend struct TileComponentWindow<T>;
	typedef grk_buf2d<T, AllocatorAligned> Buf2dAligned;

  private:
	ResWindow(grk_rect32 tileCompAtRes, grk_rect32 resWindowPadded,
			  Buf2dAligned* resWindowBufAtLowerResPadded, uint32_t filterWidth)
		: allocated_(false), resWindowBufPadded_(new Buf2dAligned(resWindowPadded))
	{
		if(resWindowBufAtLowerResPadded)
		{
			bandWindowBuffersPadded_.push_back(resWindowBufAtLowerResPadded);
			for(uint8_t orient = BAND_ORIENT_HL; orient < BAND_NUM_ORIENTATIONS; orient++)
			{
				auto win = getBandWindow(1, (eBandOrientation)orient, resWindowBufPadded_);
				auto full = getBandWindow(1, (eBandOrientation)orient, tileCompAtRes);
				bandWindowBuffersPadded_.push_back(
					new Buf2dAligned(win.grow_IN_PLACE(filterWidth).clip_IN_PLACE(full), true));
			}
		}
	}
	~ResWindow()
	{
		delete resWindowBufPadded_;
		for(uint8_t i = 0; i < bandWindowBuffersPadded_.size(); ++i)
		{
			if(i == BAND_ORIENT_LL)
				continue;
			delete bandWindowBuffersPadded_[i];
		}
	}
	bool alloc(bool clear)
	{
		if(allocated_)
			return true;

		// 1. allocate resolution window
		// resolution window is always allocated
		if(!resWindowBufPadded_->alloc2d(clear))
			return false;

		// 2, allocate padded band windows
		for(auto& b : bandWindowBuffersPadded_)
		{
			if(!b->alloc2d(clear))
				return false;
		}
		allocated_ = true;

		return true;
	}

  public:
	/**
	 * Get band window (in tile component coordinates) for specified number
	 * of decompositions
	 *
	 * Note: if numDecomps is zero, then the band window (and there is only one)
	 * is equal to the unreduced tile component window
	 *
	 * See table F-1 in JPEG 2000 standard
	 *
	 */
	static grk_rect32 getBandWindow(uint8_t numDecomps, eBandOrientation orientation,
									grk_rect32 tileCompWindowUnreduced)
	{
		if(numDecomps == 0)
			return tileCompWindowUnreduced;

		/* project window onto sub-band generated by `numDecomps` decompositions */
		/* See equation B-15 of the standard. */
		uint32_t bx0 = orientation & 1;
		uint32_t by0 = (uint32_t)(orientation >> 1U);

		uint32_t bx0Offset = (1U << (numDecomps - 1)) * bx0;
		uint32_t by0Offset = (1U << (numDecomps - 1)) * by0;

		uint32_t tc_originx0 = tileCompWindowUnreduced.origin_x0;
		uint32_t tc_originy0 = tileCompWindowUnreduced.origin_y0;
		uint32_t tcx0 = tileCompWindowUnreduced.x0;
		uint32_t tcy0 = tileCompWindowUnreduced.y0;
		uint32_t tcx1 = tileCompWindowUnreduced.x1;
		uint32_t tcy1 = tileCompWindowUnreduced.y1;

		return grk_rect32(
			(tc_originx0 <= bx0Offset) ? 0
									   : ceildivpow2<uint32_t>(tc_originx0 - bx0Offset, numDecomps),
			(tc_originy0 <= by0Offset) ? 0
									   : ceildivpow2<uint32_t>(tc_originy0 - by0Offset, numDecomps),
			(tcx0 <= bx0Offset) ? 0 : ceildivpow2<uint32_t>(tcx0 - bx0Offset, numDecomps),
			(tcy0 <= by0Offset) ? 0 : ceildivpow2<uint32_t>(tcy0 - by0Offset, numDecomps),
			(tcx1 <= bx0Offset) ? 0 : ceildivpow2<uint32_t>(tcx1 - bx0Offset, numDecomps),
			(tcy1 <= by0Offset) ? 0 : ceildivpow2<uint32_t>(tcy1 - by0Offset, numDecomps));
	}

  private:
	bool allocated_;
	Buf2dAligned* resWindowBufPadded_;
	std::vector<Buf2dAligned*> bandWindowBuffersPadded_;
};

} // namespace grk
